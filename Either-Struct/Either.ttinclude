<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#

MaxArgs = 16;

ObjectNamespace = this.Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint");

#>
//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;

<#
if (!String.IsNullOrEmpty(ObjectNamespace))
{
#>
namespace <#=ObjectNamespace#>
{
<#
    PushIndent("    ");
}
#>
<#
for (int it = 2; it <= MaxArgs; it++)
{
	Func<string, int, string> namer =
		it == 0 ? null :
		it == 1 ? (Func<string, int, string>)((s, i) => string.Format(s, "")) :
		(Func<string, int, string>)((s, i) => string.Format(s, i));

	var subtypesList = string.Join(", ", Enumerable.Range(1, it).Select(i => namer("T{0}", i)));
#>
public <#=TypeKind#> <#=TypeName#><<#=subtypesList#>> :
    IEither,
    IEquatable<<#=TypeName#><<#=subtypesList#>>>,
    IEquatable<IEither>
{
	// FIELDS
<#
for (int sit = 1; sit <= it; sit++)
{
#>
    private readonly T<#=sit#> value<#=sit#>;
<#
}
#>
    private readonly int selector;

	// CONSTRUCTORS
<#
for (int sit = 1; sit <= it; sit++)
{
#>
    public Either(T<#=sit#> value<#=sit#>)
    {
<#
	for (int itFld = 1; itFld <= it; itFld++)
	{
		if (itFld == sit)
        {
#>
        this.value<#=itFld#> = !typeof(T<#=itFld#>).IsValueType && value<#=itFld#> == null ? default(T<#=itFld#>) : value<#=itFld#>;
<#
		}
		else
        {
#>
        this.value<#=itFld#> = default(T<#=itFld#>);
<#
        }
	}
#>
        this.selector = <#=sit#>;
    }

<#
}
#>
	// PROPERTIES
<#
for (int sit = 1; sit <= it; sit++)
{
#>
    public T<#=sit#> Value<#=sit#>
    {
        get
        {
            if (this.selector == 0)
            {
                if (typeof(T<#=sit#>).IsValueType)
                    throw new InvalidOperationException($"The `<#=TypeName#><<#=subtypesList#>>` holds no value at all");
                return default(T<#=sit#>);
            }

            if (this.selector != <#=sit#>) throw new InvalidOperationException($"The `<#=TypeName#><<#=subtypesList#>>` holds a value of type T{this.selector}");
            return this.value<#=sit#>;
        }
    }

<#
}
#>

	// TYPE CASTS
<#
for (int sit = 1; sit <= it; sit++)
{
#>
    public static implicit operator <#=TypeName#><<#=subtypesList#>>(T<#=sit#> value)
    {
        return new <#=TypeName#><<#=subtypesList#>>(value);
    }

<#
}
#>
<#
for (int sit = 1; sit <= it; sit++)
{
#>
    public static explicit operator T<#=sit#>(<#=TypeName#><<#=subtypesList#>> value)
    {
        return value.Value<#=sit#>;
    }

<#
}
#>

	// OBJECT VALUE
    public object Value
    {
        get
        {
<#
for (int sit = 1; sit <= it; sit++)
{
#>
            if (this.selector == <#=sit#>)
                return this.value<#=sit#>;

<#
}
#>
            if (<#=string.Join(" && ", Enumerable.Range(1, it).Select(i => namer("typeof(T{0}).IsValueType", i)))#>)
                throw new InvalidOperationException($"The `<#=TypeName#><<#=subtypesList#>>` holds no value at all");

            return null;
        }
    }

    public int GetRank() => <#=it#>;
    public int GetSelectedAlternative() => this.selector;
    public Type GetAlternativeType(int alternative)
    {
<#
for (int sit = 1; sit <= it; sit++)
{
#>
        if (alternative == <#=sit#>)
            return typeof(T<#=sit#>);
<#
}
#>
        throw new ArgumentOutOfRangeException($"{nameof(alternative)} argument is out of range");
    }

    public Type GetUnderlyingType()
    {
        if (this.selector == 0)
            throw new InvalidOperationException($"There is no underlying type");
        return this.GetAlternativeType(this.selector);
    }

    public bool IsValid()
    {
        return !(this.selector == 0 && <#=string.Join(" && ", Enumerable.Range(1, it).Select(i => namer("typeof(T{0}).IsValueType", i)))#>);
    }

    public bool Equals(<#=TypeName#><<#=subtypesList#>> other)
    {
        if (this.selector == other.selector)
            return true;

<#
for (int sit = 1; sit <= it; sit++)
{
#>
        if (this.selector == <#=sit#>)
            return EqualityComparer<T<#=sit#>>.Default.Equals(this.value<#=sit#>, other.value<#=sit#>);

<#
}
#>
        return false;
    }

    public bool Equals(IEither other)
    {
        if (other == null)
            return false;

        if (this.GetUnderlyingType() == other.GetUnderlyingType())
            return this.Value.Equals(other.Value);

        return false;
    }

    public override bool Equals(object obj)
    {
        var other = obj as IEither;
        return this.Equals(other);
    }

    public override int GetHashCode()
    {
<#
for (int sit = 1; sit <= it; sit++)
{
#>
        if (this.selector == <#=sit#>)
            return EqualityComparer<T<#=sit#>>.Default.GetHashCode(this.value<#=sit#>);
<#
}
#>
		return -917340415;
    }

    public override string ToString()
    {
<#
for (int sit = 1; sit <= it; sit++)
{
#>
        if (this.selector == <#=sit#>)
            return $"{this.value<#=sit#>}";
<#
}
#>
        if (<#=string.Join(" && ", Enumerable.Range(1, it).Select(i => namer("typeof(T{0}).IsValueType", i)))#>)
            throw new InvalidOperationException($"The `<#=TypeName#><<#=subtypesList#>>` holds no value at all");
        return $"null";
    }
}

<#
}
#>
public static class Either
{
    public static readonly EitherFactory Factory = new EitherFactory();
}
<#

if (!String.IsNullOrEmpty(ObjectNamespace))
{
    PopIndent();
#>
}
<#
}
#>
<#+
	string ObjectNamespace { get; set; }
	int MaxArgs { get; set; }
	string TypeKind { get; set; }
	string TypeName { get; set; }
#>